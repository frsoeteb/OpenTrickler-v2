"""
Convert binary file into a C header file for embedding in firmware.
Combines HTTP header with binary data into a single array.

Usage:
    python bin2header.py -f ./html/favicon.ico -o ./generated/favicon.ico.h -t image/x-icon
"""

import argparse
import os

C_HEADER_TEMPLATE = """// ---------------------------------------------------------- //
// This file is autogenerated by bin2header.py; do not edit!  //
// ---------------------------------------------------------- //

#ifndef {capitalized_filename}_H_
#define {capitalized_filename}_H_

#include <stddef.h>

// HTTP header + binary data combined
static const unsigned char {varname}[] = {{
{hex_data}
}};

static const size_t {varname}_len = {total_len};

#endif  //  {capitalized_filename}_H_
"""


def main(input_filepath, output_filepath, content_type):
    with open(input_filepath, 'rb') as fp:
        binary_data = fp.read()

    # Create HTTP header
    http_header = f"HTTP/1.1 200 OK\r\nContent-Type: {content_type}\r\nCache-Control: max-age=86400\r\n\r\n"
    http_header_bytes = http_header.encode('utf-8')

    # Combine header + binary data
    combined = http_header_bytes + binary_data

    # Convert to hex array
    hex_values = ', '.join(f'0x{b:02x}' for b in combined)
    # Wrap lines at ~80 chars (roughly 12 hex values per line)
    hex_lines = []
    values = hex_values.split(', ')
    for i in range(0, len(values), 12):
        hex_lines.append('    ' + ', '.join(values[i:i+12]))
    hex_data = ',\n'.join(hex_lines)

    filename = os.path.basename(input_filepath)
    varname = filename.replace('.', '_').replace('-', '_').lower()

    c_header_string = C_HEADER_TEMPLATE.format(
        capitalized_filename=filename.upper().replace('.', '_').replace('-', '_'),
        varname=varname,
        hex_data=hex_data,
        total_len=len(combined),
    )

    with open(output_filepath, 'w', encoding='utf-8') as fp:
        fp.write(c_header_string)

    print(f"Generated {output_filepath} (header: {len(http_header_bytes)} + data: {len(binary_data)} = {len(combined)} bytes)")


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-f', '--input_filepath', required=True)
    parser.add_argument('-o', '--output_filepath', required=True)
    parser.add_argument('-t', '--content_type', default='application/octet-stream')
    args = parser.parse_args()
    main(args.input_filepath, args.output_filepath, args.content_type)
