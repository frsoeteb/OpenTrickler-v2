// ---------------------------------------------------------- //
// This file is autogenerated by html2header.py; do not edit! //
// ---------------------------------------------------------- //

#ifndef DISPLAY_MIRROR_HTML_H_
#define DISPLAY_MIRROR_HTML_H_

const char html_display_mirror_html[] = "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\n\r\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>Display Mirror</title>\n    <style>\n      canvas {\n        border: 1px solid black;\n      }\n    </style>\n  </head>\n  <body>\n    <canvas id=\"pixel-canvas\"></canvas>\n\n    <script>\n      // Get the canvas element\n      const canvas = document.getElementById(\"pixel-canvas\");\n      const context = canvas.getContext(\"2d\");\n\n      // Function to render a pixel at the specified coordinates with the specified color\n      function renderPixel(x, y, color) {\n        context.fillStyle = color;\n        context.fillRect(x, y, 4, 4);\n      }\n\n      // Scale the canvas by 4x\n      const scaleFactor = 4;\n      canvas.width = 128 * scaleFactor;\n      canvas.height = 64 * scaleFactor;\n\n      // Function to fetch and render the binary data\n      function fetchAndRender() {\n        // Fetch the binary data from the endpoint\n        fetch(\"/display_buffer\")\n          .then((response) => response.arrayBuffer())\n          .then((buffer) => {\n            // Convert the ArrayBuffer to a Uint8Array\n            const binaryData = new Uint8Array(buffer);\n\n            // Decoding the binary data\n            const tileWidth = 0x10;\n\n            for (let tileRowIdx = 0; tileRowIdx < 8; tileRowIdx++) {\n              for (let bit = 0; bit < 8; bit++) {\n                // Each tile row includes 16 * 8 bytes\n                for (let byteIdx = 0; byteIdx < tileWidth * 8; byteIdx++) {\n                  const dataOffset =\n                    byteIdx + tileRowIdx * tileWidth * 8;\n                  let data;\n                  try {\n                    data = binaryData[dataOffset];\n                  } catch (error) {\n                    console.log(dataOffset);\n                    throw error;\n                  }\n                  const color = (1 << bit) & data ? \"black\" : \"white\";\n                  renderPixel(byteIdx * scaleFactor, tileRowIdx * 8 * scaleFactor + bit * scaleFactor, color);\n                }\n              }\n            }\n          })\n          .catch((error) => {\n            console.log(\"Error fetching binary data:\", error);\n          });\n      }\n\n      // Poll the endpoint every 1 second\n      setInterval(fetchAndRender, 1000);\n    </script>\n  </body>\n</html>";

#endif  //  DISPLAY_MIRROR_HTML_H_
